use bincode::Options;
use blst::min_pk::SecretKey as mpSecretKey;
use blst::min_sig::SecretKey as msSecretKey;
use rand::{RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;
use threshold_crypto::SecretKey as tcSecretKey;
use threshold_crypto::serde_impl::SerdeSecret as tcSerdeSecret;

// if set to true will always use secret key with hex
// 408157791befddd702672dcfcfc99da3512f9c0ea818890fcb6ab749580ef2cf
const USE_SEEDED_RNG: bool = false;

fn main() {
    println!("Testing interoperability of threshold_crypto and blst");
    println!("---");
    println!("Output naming convention:");
    println!("tc* is threshold_crypto");
    println!("mp* is blst using minimal-pubkey-size operations");
    println!("ms* is blst using minimal-signature-size operations");
    println!("*sk is a secret key");
    println!("*pk is a public key");
    println!("*sig is a signature");
    println!("[x][y]verify is the verification of signature created by [x] using public key [y]");
    println!("---");
    // generate bytes for secret key
    let skb = gen_sk_bytes();
    println!("sk raw bytes: {:?}", skb);
    // parse bytes into secret key
    let tcsk = tc_sk_from_bytes(skb);
    println!("tcsk.reveal: {}", tcsk.reveal());
    println!("tcsk bincode: {}", hex::encode(bincode::serialize(&tcSerdeSecret(&tcsk)).unwrap()));
    println!("tcsk bincode bigendian: {}", hex::encode(bincode::DefaultOptions::new().with_big_endian().serialize(&tcSerdeSecret(&tcsk)).unwrap()));
    let mpsk = mp_sk_from_bytes(skb);
    println!("mpsk: {}", hex::encode(mpsk.to_bytes()));
    let mssk = ms_sk_from_bytes(skb);
    println!("mssk: {}", hex::encode(mssk.to_bytes()));
    // get public keys
    let tcpk = tcsk.public_key();
    println!("tcpk: {}", hex::encode(tcpk.to_bytes()));
    let mppk = mpsk.sk_to_pk();
    println!("mppk: {}", hex::encode(mppk.to_bytes()));
    let mspk = mssk.sk_to_pk();
    println!("mspk: {}", hex::encode(mspk.to_bytes()));
    // sign message with each key
    let mut rng = get_rng();
    let mut msg = [0; 56];
    rng.fill_bytes(&mut msg);
    println!("msg: {}", hex::encode(msg));
    let tcsig = tcsk.sign(&msg);
    println!("tcsig: {}", hex::encode(tcsig.to_bytes()));
    let dst = b"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_";
    let mpsig = mpsk.sign(&msg, dst, &[]);
    println!("mpsig: {}", hex::encode(mpsig.to_bytes()));
    let mssig = mssk.sign(&msg, dst, &[]);
    println!("mssig: {}", hex::encode(mssig.to_bytes()));
    // verify every signature with every public key
    let tctcverify = tcpk.verify(&tcsig, msg);
    println!("tctcverify: {}", tctcverify);
    let mpmpverify = mpsig.verify(&msg, dst, &[], &mppk);
    println!("mpmpverify: {:?}", mpmpverify);
    let msmsverify = mssig.verify(&msg, dst, &[], &mspk);
    println!("msmsverify: {:?}", msmsverify);
    // TODO
    // verify mpsig with mspk
    // verify mpsig with tcpk
    // verify mssig with mppk
    // verify mssig with tcpk
    // verify tcsig with mspk
    // verify tcsig with mppk
}

fn get_rng() -> ChaCha20Rng {
    let mut rng = ChaCha20Rng::from_entropy();
    if USE_SEEDED_RNG {
        let seed = [0u8; 32];
        rng = ChaCha20Rng::from_seed(seed);
    }
    return rng
}

//
// Key Generation (and serialization to bytes)
//

fn gen_sk_bytes() -> [u8; 32] {
    gen_sk_bytes_using_blst()
}

fn gen_sk_bytes_using_blst() -> [u8; 32] {
    let mut rng = get_rng();
    let mut ikm = [0u8; 32];
    rng.fill_bytes(&mut ikm);
    let sk = msSecretKey::key_gen(&ikm, &[]).unwrap();
    return sk.to_bytes()
}

#[allow(dead_code)]
fn gen_sk_bytes_using_tc() -> [u8; 32] {
    let sk = tcSecretKey::random();
    let skv = bincode::serialize(&tcSerdeSecret(&sk)).unwrap();
    // convert vec to bytes
    let mut skb = [0u8; 32];
    for (i, v) in skv.iter().enumerate() {
        skb[i] = *v;
    }
    skb
}

//
// Key Deserialization from bytes
//

fn tc_sk_from_bytes(b: [u8; 32]) -> tcSecretKey {
    // must reverse the order of bytes generated by blst
    // for bincode deserialize to work
    // because bincode defaults to little endian.
    // Can't use bincode::config().big_endian() because
    // the underlying data is 4x u64 not 32x u8
    // so this messes with the serialization.
    let mut rb = [0u8; 32];
    for (i, v) in b.iter().enumerate() {
        rb[31-i] = *v;
    }
    let sk: tcSecretKey = bincode::deserialize(&rb).unwrap();
    sk
}

fn mp_sk_from_bytes(b: [u8; 32]) -> mpSecretKey {
    let sk: mpSecretKey = mpSecretKey::from_bytes(&b).unwrap();
    sk
}

fn ms_sk_from_bytes(b: [u8; 32]) -> msSecretKey {
    // must reverse the order of bytes generated by
    // bincode serializaton of threshold_crypto SecretKey
    let sk: msSecretKey = msSecretKey::from_bytes(&b).unwrap();
    sk
}
